(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{177:function(t,s,_){"use strict";_.r(s);var r=_(0),e=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,_=t._self._c||s;return _("div",{staticClass:"content"},[_("h1",{attrs:{id:"《程序员的自我修养》笔记"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#《程序员的自我修养》笔记","aria-hidden":"true"}},[t._v("#")]),t._v(" 《程序员的自我修养》笔记")]),t._v(" "),_("h2",{attrs:{id:"接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口","aria-hidden":"true"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),_("p",[t._v("每个层次之间都需要相互通信，既然需要相互通信就必须有一个通信的协议，我们一般将其称为接口")]),t._v(" "),_("p",[t._v("开发工具与应用程序是属于同一个层次的，因为它们都使用同一个接口，那就是操作系统应用程序编程接口")]),t._v(" "),_("p",[t._v("应用程序接口的提供者是运行库")]),t._v(" "),_("h2",{attrs:{id:"操作系统模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#操作系统模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 操作系统模式")]),t._v(" "),_("p",[t._v("操作系统的一个功能是"),_("strong",[t._v("提供抽象的接口")]),t._v("，另外一个主要功能是"),_("strong",[t._v("管理硬件资源")]),t._v("。")]),t._v(" "),_("p",[t._v("监控程序就把另外的正在等待cpu资源的程序启动，使得cpu能够充分地利用起来。这种被称为"),_("strong",[t._v("多道程序")]),t._v("。当时的却大大提高了cpu的利用率。但是对于多道程序来说，程序之间"),_("strong",[t._v("不分轻重缓急")]),t._v("，如果有些程序急需使用cpu来完成一些任务（比如用户交互的任务），那么很有可能很长时间后才有机会分配到cpu。这对于有些响应时间要求高的程序来说是很致命的，想象一下你在windows上面点击鼠标10分钟以后系统才有反应，那该是多么沮丧的事。")]),t._v(" "),_("p",[t._v("经过稍微改进，程序运行模式变成了一种协作的模式，即每个程序运行一段时间以后都主动让出cpu给其他程序，使得一段时间内每个程序都有机会运行一小段时间。这对于一些交互式的任务尤为重要，比如点击一下鼠标或按下一个键盘按键后，程序索要处理的任务可能并不多，但是它需要尽快地被处理，使得用户能够立即看到效果。这种程序协作模式叫做"),_("strong",[t._v("分时系统")]),t._v("。windows3.1操作系统会判断是否有其他程序正在等待cpu，如果有，则可能暂停执行当前的程序，把cpu让出来给其他程序。如果一个在进行一个很耗时的计算，一直霸占着cpu不放，那么操作系统也没办法，其他程序都只有等着，整个系统看过去好像死机了一样。比如一个程序进入了一个while（1）的"),_("strong",[t._v("死循环")]),t._v("，那么整个系统都停止了。")]),t._v(" "),_("p",[t._v("此前在高端领域，非pc的大中小型机领域，其实已经在研究一种更为先进的操作系统模式了。这种模式就是我们现在很熟悉的"),_("strong",[t._v("多任务系统")]),t._v("，操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有应用程序都以进程（process）的方式运行在比操作系统权限更低的级别，每个进程都有自己独立的地址空间，使得进程之间的地址空间相互隔离。cpu由操作系统统一进行分配，每个进程根据进程优先级的高低都有机会得到cpu，但是，如果运行时间超出了一定的时间，操作系统会暂停该进程，将cpu资源分配给其他等待运行的进程。这种cpu的分配方式即所谓的抢占式（Preemptive），操作系统可以强制剥夺cpu资源并且分配给它认为目前最需要的进程。如果操作系统分配给每个进程的时间都很短，即cpu在多个进程间快速地切换，从而造成了很多进程都在同时运行的假象。目前几乎所有现代的操作系统都是采用这种方式，比如我们熟悉的UNIX、Linux、windows NT，以及Mac OS X等流行的操作系统")])])}],!1,null,null,null);e.options.__file="README.md";s.default=e.exports}}]);